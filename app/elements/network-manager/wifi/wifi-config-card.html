<link rel="import" href="../../../bower_components/polymer/polymer.html">

<!-- Iron Elements -->
<link rel="import" href="../../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../../bower_components/iron-icons/hardware-icons.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">

<!-- Other Elements -->
<link rel="import" href="../../../bower_components/vaadin-combo-box/vaadin-combo-box.html">

<!-- Paper Elements -->
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../../../bower_components/paper-radio-group/paper-radio-group.html">
<link rel="import" href="../../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../../bower_components/paper-toolbar/paper-toolbar.html">
<link rel="import" href="../../../bower_components/paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="../../../bower_components/paper-card/paper-card.html">

<!--network-manager-->
<link rel="import" href="./passphrase-validator.html">
<link rel="import" href="./ssid-validator.html">


<dom-module id="wifi-config-card">

  <template>

    <style is="custom-style" include="iron-flex iron-flex-alignment iron-flex-factors">

      :host{
        display: block;
      }

      .interfaceToolbar {
        --paper-toolbar-background: white;
        --paper-toolbar-color: --dark-theme-text-color;
      }

      paper-toolbar.interfaceToolbar > ::content .title{
        margin-left: 8px;
      }

      .container {
        margin-bottom: 2%;
        margin-left: 10%;
        margin-right: 10%;
        @apply(--layout-flex);
      }

      .selections {
        margin: 0 auto;
        border-bottom: 1px solid grey;
        border-top: 1px solid grey;
      }

      .modeFooter {
        padding-top: 12px;
      }

      .actions {
        @apply(--layout-horizontal);
        @apply(--layout-end-justified);
        padding: 8px 36px 16px 36px;
      }

      paper-card {
        width: 100%;
        height: 100%;
      }

      paper-radio-group {
        padding: 4px 8px 0px 8px;
      }

      paper-toggle-button {
        padding: 8px 8px 4px 8px;
      }

      paper-dropdown-menu {
        /*Ensure that we have a nice selectable height and width*/
        width: 100%;
        max-height: 200px;
        min-width: 161px;
      }

      paper-listbox {
        /*Ensure that we have a nice selectable height and width*/
        width: 100%;
        max-height: 200px;
        min-width: 161px;
      }

      [hidden] {
        display: none !important;
      }
    </style>

    <ssid-validator validator-name="ssid"></ssid-validator>
    <passphrase-validator validator-name="passphrase"></passphrase-validator>
    <passphrase-validator validator-name="clientPass" allow-empty></passphrase-validator>
    <!--<ipv4-addr-validator validator-name="hotspotAddr"></ipv4-addr-validator>-->

    <paper-card>

      <!--Header for each interface-->
      <paper-toolbar class="interfaceToolbar">
        <div class="title">
          <iron-icon icon="hardware:developer-board"></iron-icon>
          <span>[[config.name]]</span>
        </div>
      </paper-toolbar>

      <!--Config for this interface-->
      <div class="container">
        <div class="selections">
          <!--<label id="labelModeN">Mode:</label>-->
          <paper-radio-group selected="{{selectedMode}}" id="mode">
            <paper-radio-button name="none">StandBy</paper-radio-button>
            <paper-radio-button hidden$="[[_isManaged(config)]]" accesskey=""name="client">Client</paper-radio-button>
            <paper-radio-button hidden$="[[_isManaged(config)]]" name="hotspot">Hotspot</paper-radio-button>
            <paper-radio-button hidden$="[[!_isManaged(config)]]" name="bridge">Bridged AP</paper-radio-button>

          </paper-radio-group>
        </div>

        <div class="inputs">

          <!--Hotspot Mode Inputs-->
          <div hidden$="{{!_isHotspot(selectedMode)}}">

            <paper-input id="hotspotSsid"
                         label="SSID"
                         value="{{selectedSsid}}"
                         auto-validate
                         validator="ssid"
                         error-message="Must be 4 to 32 alpha-numeric characters!"
                         invalid="{{isSsidInvalid}}"
                         maxlength="32">
            </paper-input>

            <paper-input id="hotspotPassphrase"
                         label="WPA Passphrase"
                         value="{{selectedPassphrase}}"
                         auto-validate
                         validator="passphrase"
                         error-message="Must be 8 to 63 alpha-numeric and special characters."
                         invalid="{{isPassphraseInvalid}}"
                         maxlength="63">
            </paper-input>

            <!--todo validate this-->
            <paper-input id="hotspotAddress"
                         label="Hotspot Address"
                         value="{{selectedAddress}}"
                         hidden="{{_isBridgedHotspot(selectedMode)}}">
            </paper-input>

            <paper-dropdown-menu label="Band">
              <paper-listbox class="dropdown-content" attr-for-selected="name" selected="{{selectedBand}}">
                <template is="dom-repeat" items="[[bands]]" as="band">
                  <paper-item name="[[band]]">[[_formatBand(band)]]GHz</paper-item>
                </template>
  </paper-listbox>
  </paper-dropdown-menu>

  <paper-dropdown-menu label="Channel">
    <paper-listbox class="dropdown-content" attr-for-selected="name" selected="{{selectedChannel}}">
      <template is="dom-repeat" items="[[_getChannels(selectedBand)]]" as="channel">
                  <paper-item name="[[channel]]">[[channel]]</paper-item>
                </template>
    </paper-listbox>
  </paper-dropdown-menu>

  <div class="modeFooter">
    <paper-toggle-button id="tglAutoHotspot" checked="{{selectedAutoConnect}}" hidden$="[[_isManaged(config)]]">Enable At Boot</paper-toggle-button>
  </div>
  </div>

  <!--Client Mode Inputs-->
  <div hidden$="{{!_isClient(selectedMode)}}">

    <vaadin-combo-box id="comboboxNetwork" allow-custom-value items="[[availableNetworks]]" label="Network" item-label-path="ssid" item-value-path="ssid" value="{{selectedNetwork}}">

    </vaadin-combo-box>

    <paper-input id="clientPassphrase" label="Passphrase" value="{{clientPassphrase}}" auto-validate validator="clientPass" error-message="Alpha-numeric and or special characters only." invalid="{{isClientPassphraseInvalid}}" maxlength="63">
    </paper-input>

  </div>

  </div>

  </div>

  <div class="actions">
    <paper-icon-button disabled="{{!isChange}}" icon="icons:clear" on-tap="clear"></paper-icon-button>
    <paper-icon-button disabled="{{isApplyDisabled}}" icon="icons:save" on-tap="save"></paper-icon-button>
  </div>

  </paper-card>

  </template>

  <script src="/elements/network-manager/scripts/bundle.js"></script>
  <script>
    (function() {
      'use strict';

      const TAG = 'NETWORK_MGR:WIFI:CONFIG_CARD';
      const debug = window.Bits.utils.getDebugger(TAG);

      const COLLAPSE_ICONS = {
        expanded: 'icons:expand-less',
        collapsed: 'icons:expand-more'
      };

      const CHANNELS = {
        //802.11a channels for 5.0GHz
        a: [34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161],

        //802.11bg channels for 2.4GHz
        bg: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
      };

      const BAND_A = 'a';
      const BAND_BG = 'bg';
      const BANDS = [BAND_A, BAND_BG];

      const DEFAULT_PASSPHRASE = 'newtons#Per!meter';
      const DEFAULT_BAND = BAND_BG;

      const DEFAULT_ADDRESS = '10.42.0.1/24';

      const getDefaultChannel = function(band) {
        switch (band) {
          // 48 is known to work on the laptop
          case BAND_A:
            return 48;

            // Everything that is not 5GHz just get's ch 6
          default:
            return 6;
        }
      };

      const MODES = {
        BRIDGE: 'bridge',
        HOTSPOT: 'hotspot',
        CLIENT: 'client',
        NONE: 'none'
      };

      Polymer({

        is: 'wifi-config-card',

        //From the server
        properties: {
          config: {
            type: Object,
            notify: true,
            observer: '_observeConfig'
          },

          //From the server
          availableNetworks: {
            type: Array,
            notify: true,
            value: function() {
              return [];
            },
            observer: '_observeAvailableNetworks'
          },

          bitsId: {
            type: String,
            notify: true,
          },

          defaultSsid: {
            type: String,
            notify: true,
            computed: '_computeDefaultSSID(bitsId, config)'
          },

          //Default values
          bands: {
            type: Array,
            readOnly: true,
            value: function() {
              return BANDS;
            }
          },

          //Default values
          channels: {
            type: Object,
            readOnly: true,
            value: function() {
              return CHANNELS;
            }
          },

          //Default values
          collapseIcon: {
            type: String,
            notify: true,
            value: COLLAPSE_ICONS.collapsed
          },

          selectedMode: {
            type: String,
            notify: true,
            value: function() {
              return MODES.NONE;
            },
            observer: '_observeSelectedMode'
          },

          //Hotspot mode
          selectedSsid: {
            type: String,
            notify: true,
            observer: '_observeSelectedSsid'
          },

          selectedAddress: {
            type: String,
            notify: true,
            observer: '_observeSelectedAddress'
          },

          //Hotspot mode
          selectedPassphrase: {
            type: String,
            notify: true,
            value: function() {
              return DEFAULT_PASSPHRASE;
            },
            observer: '_observeSelectedPassphrase'
          },

          //Hotspot mode
          selectedBand: {
            type: String,
            notify: true,
            value: function() {
              return DEFAULT_BAND;
            },
            observer: '_observeSelectedBand'
          },

          //Hotspot mode
          selectedChannel: {
            type: Number,
            notify: true,
            value: function() {
              //Ensure we are on channel 1 - 11 for default since USA supports those
              return getDefaultChannel(BAND_BG);
            },
            observer: '_observeSelectedChannel'
          },

          isResolveBitsId: {
            type: Boolean,
            notify: true,
            observer: '_observeIsResolveBitsId'
          },

          selectedAutoConnect: {
            type: Boolean,
            notify: true,
            value: false,
            observer: '_observeSelectedAutoConnect'
          },

          //Client mode
          selectedNetwork: {
            type: String,
            notify: true,
            observer: '_observeSelectedNetwork'
          },

          //Client mode
          clientPassphrase: {
            type: String,
            notify: true,
            observer: '_observeClientPassphrase'
          },

          //Hotspot mode
          isSsidInvalid: {
            type: Boolean,
            notify: true,
            value: false
          },

          //Hotspot mode
          isPassphraseInvalid: {
            type: Boolean,
            notify: true,
            value: false
          },

          //Client mode
          isClientPassphraseInvalid: {
            type: Boolean,
            notify: true,
            value: false
          },

          isFormInvalid: {
            type: Boolean,
            computed: '_computeIsFormInvalid(isSsidInvalid, isPassphraseInvalid, isAddressInvalid, isClientPassphraseInvalid)',
          },

          isChange: {
            type: Boolean,
            value: false,
          },

          isApplyDisabled: {
            type: Boolean,
            computed: '_computeIsApplyDisabled(isFormInvalid, isChange)'
          }
        },

        _isManaged(config) {
          if( config.networkDevice.state === 'unmanaged') {
            return true;
          } else {
            return false;
          }
        },

        _isNull(ref) {
          return (ref === undefined || ref === null);
        },

        _isAnyNull(refArray) {
          return refArray.some((ref) => this._isNull(ref));
        },

        _computeIsFormInvalid: function(isSsidInvalid, isPassphraseInvalid, isAddressInvalid, isClientPassphraseInvalid) {
          if (this._isAnyNull([isSsidInvalid, isPassphraseInvalid, isAddressInvalid, isClientPassphraseInvalid])) {
            // If any param is undefined then we want to make sure the form is valid since we are probably loading
            return false;
          }

          return isSsidInvalid || isPassphraseInvalid || isAddressInvalid || isClientPassphraseInvalid;
        },

        _computeIsApplyDisabled: function(isFormInvalid, isChange) {
          if (this._isAnyNull([isFormInvalid, isChange])) {
            // If we don't have all our properties we allow save to be disabled.
            return false;
          }

          return isFormInvalid || !isChange;
        },

        _computeDefaultSSID: function(bitsId, config) {
          debug('_computeDefaultSSID', bitsId, config);
          if (bitsId && config) {
            //Since we have a non-standard hostname structure we always just get the first string and concat with the iface
            return bitsId.split('.')[0] + '_' + config.name.substring((config.name.length - 4));
          } else {
            return null;
          }
        },

        _formatBand: function(band) {
          debug('_formatBand', band);
          switch (band) {
            case BAND_A:
              return '5.0';
            case BAND_BG:
              return '2.4';
            default:
              return 'NA';
          }
        },

        _getChannels: function(band) {
          debug('_getChannels', band);
          switch (band) {
            case 'bg':
              //Prevent timing issues with loading
              if (this.channels && this.channels.hasOwnProperty('bg')) {
                return this.channels.bg;
              } else {
                return CHANNELS.bg;
              }
            case 'a':
              //Prevent timing issues with loading
              if (this.channels && this.channels.hasOwnProperty('a')) {
                return this.channels.a;
              } else {
                return CHANNELS.a;
              }
            default:
              return [];
          }
        },

        _handleChange: function() {
          debug('_handleChange', this.config.name);
          this.set('isChange', true);
        },

        _isHotspot: function(mode) {
          debug('_isHotspot', mode);
          return mode === 'hotspot' || mode === 'bridge';
        },

        _isBridgedHotspot: function(mode) {
          return mode === 'bridge'
        },
        _isClient: function(mode) {
          debug('_isClient', mode);
          return mode === 'client';
        },

        _setClientModeDefaults: function() {
          debug('_setClientModeDefaults');
          if (this.config.client.ssid !== null) {
            this.set('selectedNetwork', this.config.client.ssid);
          } else {
            this.set('selectedNetwork', null);
          }

          if (this.config.client.security !== null) {
            this.set('selectedSecurity', this.config.client.security);
          } else {
            this.set('selectedSecurity', null);
          }

          if (this.config.client.password !== null) {
            this.set('clientPassphrase', this.config.client.password);
          } else {
            this.set('clientPassphrase', null);
          }
        },

        _setHotspotModeDefaults: function() {
          debug('_setHotspotModeDefaults');
          if (!this._isNull(this.config.hotspot.ssid)) {
            this.set('selectedSsid', this.config.hotspot.ssid);
          } else {
            this.set('selectedSsid', this.defaultSsid);
          }

          if (!this._isNull(this.config.hotspot.password)) {
            this.set('selectedPassphrase', this.config.hotspot.password);
          } else {
            this.set('selectedPassphrase', DEFAULT_PASSPHRASE);
          }

          if (!this._isNull(this.config.hotspot.address)) {
            this.set('selectedAddress', this.config.hotspot.address);
          } else {
            this.set('selectedAddress', DEFAULT_ADDRESS);
          }

          if (!this._isNull(this.config.hotspot.resolveBitsId)) {
            this.set('isResolveBitsId', this.config.hotspot.resolveBitsId);
          } else {
            this.set('isResolveBitsId', false);
          }

          if (!this._isNull(this.config.hotspot.band)) {
            this.set('selectedBand', this.config.hotspot.band);
          } else {
            this.set('selectedBand', DEFAULT_BAND);
          }

          if (!this._isNull(this.config.hotspot.channel)) {
            this.set('selectedChannel', this.config.hotspot.channel);
          } else {
            this.set('selectedChannel', getDefaultChannel(BAND_BG));
          }

          if (!this._isNull(this.config.hotspot.isAutoConnect)) {
            this.set('selectedAutoConnect', this.config.hotspot.isAutoConnect);
          } else {
            this.set('selectedAutoConnect', false);
          }
        },

        _initialize: function(config) {
          if (!this._isNull(config.mode)) {
            this.set('selectedMode', config.mode);
          } else {
            console.error('Unable to set config. Mode is null.');
          }

          switch (config.mode) {
            case MODES.HOTSPOT:
              this.set('selectedSsid', config.hotspot.ssid);
              this.set('selectedPassphrase', config.hotspot.password);
              this.set('selectedAddress', config.hotspot.address);
              this.set('selectedBand', config.hotspot.band);
              this.set('selectedChannel', config.hotspot.channel);
              this.set('selectedAutoConnect', config.hotspot.isAutoConnect);
              return;

            case MODES.CLIENT:
              this.set('selectedNetwork', config.client.ssid);
              this.set('clientPassphrase', config.client.password);
              return;

            case MODES.NONE:
              // do nothing since all the fields are init to null anyway
              break;

            default:
              // do nothing since all the fields are init to null anyway
              break;
          }
        },

        _observeConfig: function(newVal, oldVal) {
          debug('_observeConfig', newVal, oldVal);
          //When this changes for the first time we want to set the selected values
          if (oldVal === undefined) {
            this._initialize(newVal);
          }
        },

        _observeSelectedMode: function(newVal, oldVal) {
          debug('_observeSelectedMode', newVal, oldVal);
          if (oldVal === undefined) {
            return;
          }

          // Always set change and set defaults so we have values in the fields
          this._handleChange();
          this._setClientModeDefaults();
          this._setHotspotModeDefaults();

          switch (newVal) {
            case MODES.CLIENT:
              this.scan(this.config.name);
              break;
            default:
              break;
          }
        },

        _observeSelectedSsid: function(newVal, oldVal) {
          debug('_observeSelectedSsid', newVal, oldVal);
          if (oldVal === undefined) {
            return;
          }

          this._handleChange();
        },

        _observeSelectedPassphrase: function(newVal, oldVal) {
          debug('_observeSelectedPassphrase', newVal, oldVal);
          if (oldVal === undefined) {
            return;
          }

          this._handleChange();
        },

        _observeSelectedAddress: function(newVal, oldVal) {
          debug('_observeSelectedAddress', newVal, oldVal);
          if (oldVal === undefined) {
            return;
          }

          this._handleChange();
        },

        _observeSelectedBand: function(newVal, oldVal) {
          debug('_observeSelectedBand', newVal, oldVal);
          if (oldVal === undefined) {
            return;
          }

          this.set('selectedChannel', getDefaultChannel(newVal));
          this._handleChange();
        },

        _observeSelectedChannel: function(newVal, oldVal) {
          debug('_observeSelectedChannel', newVal, oldVal);
          if (oldVal === undefined) {
            return;
          }

          this._handleChange();
        },

        _observeIsResolveBitsId: function(newVal, oldVal) {
          debug('_observeIsResolveBitsId', newVal, oldVal);
          if (oldVal === undefined) {
            return;
          }

          this._handleChange();
        },

        _observeSelectedAutoConnect: function(newVal, oldVal) {
          debug('_observeSelectedAutoConnect', newVal, oldVal);
          if (oldVal === undefined) {
            return;
          }

          this._handleChange();
        },

        _observeSelectedNetwork: function(newVal, oldVal) {
          debug('_observeSelectedNetwork', newVal, oldVal);
          if (oldVal === undefined || newVal === undefined) {
            return;
          }

          //Find the network security setting and automagically update the security combobox so they remain linked
          const network = this.availableNetworks.find(network => network.ssid === newVal);
          if (network) {
            this.set('selectedSecurity', network.security);
          } else {
            //If this is a hidden network it won't be in the list so set it to null and let the user enter a val.
            this.set('selectedSecurity', null);
          }

          this._handleChange();
        },

        _observeClientPassphrase: function(newVal, oldVal) {
          debug('_observeClientPassphrase', newVal, oldVal);
          if (oldVal === undefined) {
            return;
          }

          this._handleChange();
        },

        _observeAvailableNetworks: function(newVal, oldVal) {
          debug('_observeAvailableNetworks', newVal, oldVal);
          if (oldVal === undefined) {
            return;
          }
          // TODO not sure we need this
        },

        _clearClientParams: function() {
          debug('_clearClientParams');
          this.config.client.ssid = null;
          this.config.client.password = null;
          this.config.client.signal = null;
          this.config.client.isAutoConnect = false;
        },

        /**
         * Clears the hotspot configuration from the config object that represents what the server
         * will get/what we get from the server.
         */
        _clearHotspotParams: function() {
          debug('_clearHotspotParams');
          this.config.hotspot.ssid = null;
          this.config.hotspot.password = null;
          this.config.hotspot.band = null;
          this.config.hotspot.channel = null;
          this.config.hotspot.isAutoConnect = false;
        },

        /**
         * Clear any client configs and set the config props to match the selected vals so
         * we can send it to the server
         **/
        finalize: function() {
          debug('finalize', this.config.name, this.selectedMode);

          this.config.mode = this.selectedMode;

          switch (this.selectedMode) {
            case MODES.NONE:
              debug('finalize: none');
              this._clearHotspotParams();
              this._clearClientParams();
              break;
            case MODES.CLIENT:
              debug('finalize: client');
              this._clearHotspotParams();
              this.config.client.ssid = this.selectedNetwork;
              this.config.client.password = this.clientPassphrase;
              break;
            case MODES.HOTSPOT:
              debug('finalize: hotspot');
              this._clearClientParams();
              this.config.hotspot.ssid = this.selectedSsid;
              this.config.hotspot.password = this.selectedPassphrase;
              this.config.hotspot.address = this.selectedAddress;
              this.config.hotspot.band = this.selectedBand;
              this.config.hotspot.channel = this.selectedChannel;
              this.config.hotspot.isAutoConnect = this.selectedAutoConnect;
              this.config.hotspot.resolveBitsId = this.isResolveBitsId;
              break;
            case MODES.BRIDGE:
              this._clearClientParams();
              this.config.hotspot.ssid = this.selectedSsid;
              this.config.hotspot.password = this.selectedPassphrase;
              this.config.hotspot.address = null;
              this.config.hotspot.band = this.selectedBand;
              this.config.hotspot.channel = this.selectedChannel;
              this.config.hotspot.isAutoConnect = this.selectedAutoConnect;
              this.config.hotspot.resolveBitsId = this.isResolveBitsId;
            default:
              console.error('Cannot finalize with unknown mode!');
              break;
          }
        },

        scan: function() {
          this.fire('wifi-scan', this.config.name);
        },

        clear: function() {
          this._initialize(this.config);
          this.set('isChange', false);
        },

        save: function() {
          this.finalize();
          this.fire('save-wifi-config', this.config);
        },

      }); //End Polymer

    }());
  </script>

</dom-module>
